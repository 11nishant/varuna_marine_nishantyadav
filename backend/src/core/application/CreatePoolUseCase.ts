import { Pool, PoolMember } from '../domain/Pool';
import { ComplianceRepository } from '../ports/ComplianceRepository';
import { PoolRepository } from '../ports/PoolRepository';

export class CreatePoolUseCase {
  constructor(
    private complianceRepository: ComplianceRepository,
    private poolRepository: PoolRepository
  ) {}

  async execute(year: number, shipIds: string[]): Promise<Pool> {
    const members: PoolMember[] = [];
    let totalCb = 0;

    // Fetch adjusted CB for each ship
    for (const shipId of shipIds) {
      const cbBefore = await this.complianceRepository.findAdjustedCb(shipId, year);
      members.push(new PoolMember(shipId, cbBefore, cbBefore)); // cbAfter will be calculated
      totalCb += cbBefore;
    }

    // Validate pool sum
    if (totalCb < 0) {
      throw new Error('Pool sum must be >= 0');
    }

    // Greedy allocation: sort by CB descending
    const sortedMembers = [...members].sort((a, b) => b.cbBefore - a.cbBefore);
    const deficits: PoolMember[] = [];
    const surpluses: PoolMember[] = [];

    for (const member of sortedMembers) {
      if (member.cbBefore < 0) {
        deficits.push(member);
      } else {
        surpluses.push(member);
      }
    }

    // Transfer surplus to deficits
    let surplusIndex = 0;
    for (const deficit of deficits) {
      const deficitAmount = Math.abs(deficit.cbBefore);
      
      while (deficitAmount > 0 && surplusIndex < surpluses.length) {
        const surplus = surpluses[surplusIndex];
        const transferAmount = Math.min(deficitAmount, surplus.cbBefore);
        
        deficit.cbAfter = deficit.cbAfter + transferAmount;
        surplus.cbAfter = surplus.cbAfter - transferAmount;
        
        if (surplus.cbAfter <= 0) {
          surplusIndex++;
        }
        
        if (deficit.cbAfter >= 0) {
          break;
        }
      }

      // Validate: deficit ship cannot exit worse
      if (deficit.cbAfter < deficit.cbBefore) {
        throw new Error(`Deficit ship ${deficit.shipId} cannot exit worse`);
      }
    }

    // Validate: surplus ship cannot exit negative
    for (const surplus of surpluses) {
      if (surplus.cbAfter < 0) {
        throw new Error(`Surplus ship ${surplus.shipId} cannot exit negative`);
      }
    }

    // Update members with calculated cbAfter
    const finalMembers = members.map(m => {
      const updated = sortedMembers.find(sm => sm.shipId === m.shipId);
      return updated || m;
    });

    const pool = new Pool(
      '', // Will be generated by repository
      year,
      new Date(),
      finalMembers
    );

    return this.poolRepository.create(pool);
  }
}

